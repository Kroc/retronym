// retronym (C) copyright Kroc Camen 2017, 2018
// BSD 2-clause licence; see LICENSE.TXT

// retronym requires an indent to distinguish between a definition
// (such as labels) and the recall of a value, making the language
// whitespace-aware somewhat like python. therefore, the `whitespace`
// rule is defined without new-line and we manage that separately

whitespace      = _{ " " | "\t" }

comment         = _{ ";" ~ (!newline ~ any)* ~ newline }

// support either CRLF or LF, but don't take CRLF to be two new-lines.
// we want to capture newlines so that we check for immediate indentation

newline         = @{ "\r"? ~ "\n" }

// outline:
//==============================================================================

rym             = { soi ~ ( newline | comment | root )* ~ eoi }

// each line can be only one of two kinds:
// (excluding blank and comment lines)
//
// 1. no-indent: a definition of some sort
// 2. with-indent: a list of expressions
//
//TODO: make the indent/no-indent split
root            = !{ whitespace* ~ list }

// almost everything in Retronym is an implicit list,
// commas are optional
list            = _{ expr ~ ","? ~ list? }

expr            = _{ number | atom }

//==============================================================================

alpha           = _{ 'a'..'z' | 'A'..'Z' }
alpha_num       = _{ 'a'..'z' | 'A'..'Z' | '0'..'9' }
alpha_num_un    = _{ 'a'..'z' | 'A'..'Z' | '0'..'9' | "_" } 
digit           = _{ '0'..'9' }
digit_leading   = _{ '1'..'9' }
digit_hex       = _{ '0'..'9' | 'a'..'f' | 'A'..'F' }
digit_bin       = _{ '0'..'1' }

// an integer [decimal] number uses digits "0"-"9" but cannot begin with "0"
// TODO: negative integers
// TODO: float numbers

int_number = @{digit_leading ~ digit* }

// a hexadecimal number uses a "$" sigil, followed by up to 32 hexadecimals
// TODO: some kind of separator for very large hex numbers?

hex_number = @{ "$" ~ digit_hex{1,32} }

// a binary number uses a "%" sigil, followed by up to 64 binary decimals

bin_number = @{ "%" ~ digit_bin{1,64} }

// this rule is silent as we will parse the specific type of number
// (dec, bin, hex) rather than this top-level token

number = _{ int_number | hex_number | bin_number }

// TODO: these are not all operators yet; pending more rules

operator = { "," | "+" | "-" | "*" | "/" | "^" | "&" | "|" | "#" | "(" | ")" }

//------------------------------------------------------------------------------

// an atom is a "keyword", this predominantly includes assembly mnemonics.
// an atom consists of a-z, 0-9, but cannot begin with a number

atom            = @{ alpha ~ alpha_num* }

id              = @{ alpha ~ alpha_num_un* }

label           = @{ ":" ~ id }

attribute       = @{ "@" ~ id }

structure       = @{ "%" ~ id }

