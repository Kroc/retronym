// retronym (C) copyright Kroc Camen 2017, 2018
// BSD 2-clause licence; see LICENSE.TXT

// retronym requires an indent to distinguish between a definition
// (such as labels) and the recall of a value, making the language
// whitespace-aware somewhat like python. therefore, the `whitespace`
// rule is defined without new-line and we manage that separately

whitespace      = _{ " " | "\t" }

comment         = _{ ";" ~ (!newline ~ any)* ~ newline }

// support either CRLF or LF, but don't take CRLF to be two new-lines.
// we want to capture newlines so that we check for immediate indentation

newline         = @{ "\r"? ~ "\n" }

// outline:
//==============================================================================

rym             = _{ soi ~ ( newline | comment | root )* ~ eoi }

// each line can be only one of two kinds:
// (excluding blank and comment lines)
//
// 1. no-indent: a definition of some sort
// 2. with-indent: a list of expressions
//
//TODO: make the indent/no-indent split
root            = !{ whitespace* ~ list }

// almost everything in Retronym is an implicit list,
// commas are optional
list            = _{ expr ~ ","? ~ list? }

expr            = _{ value ~ ( operator ~ expr )? }

value           = _{ number | atom }

//==============================================================================

alpha           = _{ 'a'..'z' | 'A'..'Z' }
alpha_num       = _{ 'a'..'z' | 'A'..'Z' | '0'..'9' }
alpha_num_un    = _{ 'a'..'z' | 'A'..'Z' | '0'..'9' | "_" } 
digit           = _{ '0'..'9' }
digit_leading   = _{ '1'..'9' }
digit_hex       = _{ '0'..'9' | 'a'..'f' | 'A'..'F' }
digit_bin       = _{ '0'..'1' }

// an integer [decimal] number uses digits "0"-"9" but cannot begin with "0"
// TODO: negative integers
// TODO: float numbers

int_number      = @{ "-"? ~ digit_leading ~ digit* }

// a hexadecimal number uses a "$" sigil, followed by up to 32 hexadecimals
// TODO: some kind of separator for very large hex numbers?

hex_number      = @{ "$" ~ digit_hex{1,32} }

// a binary number uses a "%" sigil, followed by up to 64 binary decimals

bin_number      = @{ "%" ~ digit_bin{1,64} }

// this rule is silent as we will parse the specific type of number
// (dec, bin, hex) rather than this top-level token

number          = _{ int_number | hex_number | bin_number }

operator        = _{
                    op_pow |
                    op_add | op_sub | op_mul | op_div | op_mod |
                    op_xor | op_and | op_or | op_shl | op_shr
                }

//TODO: repeat: "x" (is this even an operator?)
//      range:  ".." / "..."
//      rolls?  "<<<" / ">>>"
//      not:    "!"? (overused), perhaps "~" instead?
//              big question regarding number of bits; require an operand?
//              e.g. "$FFFF ~ 16"

op_pow          = { "**" }  // power/exponention

op_add          = { "+" }   // add
op_sub          = { "-" }   // subtract
op_mul          = { "*" }   // multiply
op_div          = { "/" }   // divide
op_mod          = { "\\" }  // modulo (usually "%", already used though)

op_xor          = { "^" }   // exclusive-or
op_and          = { "&" }   // and
op_or           = { "|" }   // or
op_shl          = { "<<" }  // shift-left
op_shr          = { ">>" }  // shift-right

//------------------------------------------------------------------------------

// an atom is a "keyword", this predominantly includes assembly mnemonics.
// an atom consists of a-z, 0-9, but cannot begin with a number

atom            = @{ alpha ~ alpha_num* }

id              = @{ alpha ~ alpha_num_un* }

label           = @{ ":" ~ id }

attribute       = @{ "@" ~ id }

structure       = @{ "%" ~ id }

